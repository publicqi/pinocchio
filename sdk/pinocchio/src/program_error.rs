//! Errors generated by programs.
//!
//! Current implementation is based on the `ProgramError` enum from
//! the Solana SDK:
//!
//! <https://github.com/anza-xyz/solana-sdk/blob/master/program-error/src/lib.rs>

/// Reasons the program may fail.
#[derive(Clone, Debug, Eq, PartialEq)]
#[repr(u8)]
pub enum ProgramError {
    /// Allows on-chain programs to implement program-specific error types and see them returned
    /// by the Solana runtime. A program-specific error may be any type that is represented as
    /// or serialized to a u32 integer.
    ///
    /// Custom program error: `{0:#x}`
    Custom(u32) = 1,

    /// The arguments provided to a program instruction were invalid
    InvalidArgument = 2,

    /// An instruction's data contents was invalid
    InvalidInstructionData = 3,

    /// An account's data contents was invalid
    InvalidAccountData = 4,

    /// An account's data was too small
    AccountDataTooSmall = 5,

    /// An account's balance was too small to complete the instruction
    InsufficientFunds = 6,

    /// The account did not have the expected program id
    IncorrectProgramId = 7,

    /// A signature was required but not found
    MissingRequiredSignature = 8,

    /// An initialize instruction was sent to an account that has already been initialized
    AccountAlreadyInitialized = 9,

    /// An attempt to operate on an account that hasn't been initialized
    UninitializedAccount = 10,

    /// The instruction expected additional account keys
    NotEnoughAccountKeys = 11,

    /// Failed to borrow a reference to account data, already borrowed
    AccountBorrowFailed = 12,

    /// Length of the seed is too long for address generation
    MaxSeedLengthExceeded = 13,

    /// Provided seeds do not result in a valid address
    InvalidSeeds = 14,

    /// IO Error
    BorshIoError = 15,

    /// An account does not have enough lamports to be rent-exempt
    AccountNotRentExempt = 16,

    /// Unsupported sysvar
    UnsupportedSysvar = 17,

    /// Provided owner is not allowed
    IllegalOwner = 18,

    /// Accounts data allocations exceeded the maximum allowed per transaction
    MaxAccountsDataAllocationsExceeded = 19,

    /// Account data reallocation was invalid
    InvalidRealloc = 20,

    /// Instruction trace length exceeded the maximum allowed per transaction
    MaxInstructionTraceLengthExceeded = 21,

    /// Builtin programs must consume compute units
    BuiltinProgramsMustConsumeComputeUnits = 22,

    /// Invalid account owner
    InvalidAccountOwner = 23,

    /// Program arithmetic overflowed
    ArithmeticOverflow = 24,

    /// Account is immutable
    Immutable = 25,

    /// Incorrect authority provided
    IncorrectAuthority = 26,
}

/// Builtin return values occupy the upper 32 bits
const BUILTIN_BIT_SHIFT: usize = 32;

impl From<ProgramError> for u64 {
    fn from(error: ProgramError) -> Self {
        match error {
            ProgramError::Custom(error) => {
                if error == 0 {
                    // CUSTOM_ZERO
                    1 << BUILTIN_BIT_SHIFT
                } else {
                    error as u64
                }
            }
            // SAFETY: the discriminant is always the first field for non Custom
            _ => {
                let discriminant = unsafe { *(&error as *const ProgramError as *const u8) };
                (discriminant as u64) << BUILTIN_BIT_SHIFT
            }
        }
    }
}

impl From<u64> for ProgramError {
    fn from(value: u64) -> Self {
        let discriminant = (value >> BUILTIN_BIT_SHIFT) as u8;
        match discriminant {
            1 => Self::Custom(0),
            // SAFETY: the discriminant is always the first field for non Custom
            2..=26 => unsafe { (*(&discriminant as *const u8 as *const ProgramError)).clone() },
            _ => Self::Custom(value as u32),
        }
    }
}

/// A trait for converting a program error to a `&str`.
pub trait ToStr {
    fn to_str<E>(&self) -> &'static str
    where
        E: 'static + ToStr + TryFrom<u32>;
}

impl ToStr for ProgramError {
    fn to_str<E>(&self) -> &'static str
    where
        E: 'static + ToStr + TryFrom<u32>,
    {
        match self {
            Self::Custom(error) => {
                if let Ok(custom_error) = E::try_from(*error) {
                    custom_error.to_str::<E>()
                } else {
                    "Error: Unknown"
                }
            }
            Self::InvalidArgument => "Error: InvalidArgument",
            Self::InvalidInstructionData => "Error: InvalidInstructionData",
            Self::InvalidAccountData => "Error: InvalidAccountData",
            Self::AccountDataTooSmall => "Error: AccountDataTooSmall",
            Self::InsufficientFunds => "Error: InsufficientFunds",
            Self::IncorrectProgramId => "Error: IncorrectProgramId",
            Self::MissingRequiredSignature => "Error: MissingRequiredSignature",
            Self::AccountAlreadyInitialized => "Error: AccountAlreadyInitialized",
            Self::UninitializedAccount => "Error: UninitializedAccount",
            Self::NotEnoughAccountKeys => "Error: NotEnoughAccountKeys",
            Self::AccountBorrowFailed => "Error: AccountBorrowFailed",
            Self::MaxSeedLengthExceeded => "Error: MaxSeedLengthExceeded",
            Self::InvalidSeeds => "Error: InvalidSeeds",
            Self::BorshIoError => "Error: BorshIoError",
            Self::AccountNotRentExempt => "Error: AccountNotRentExempt",
            Self::UnsupportedSysvar => "Error: UnsupportedSysvar",
            Self::IllegalOwner => "Error: IllegalOwner",
            Self::MaxAccountsDataAllocationsExceeded => "Error: MaxAccountsDataAllocationsExceeded",
            Self::InvalidRealloc => "Error: InvalidRealloc",
            Self::MaxInstructionTraceLengthExceeded => "Error: MaxInstructionTraceLengthExceeded",
            Self::BuiltinProgramsMustConsumeComputeUnits => {
                "Error: BuiltinProgramsMustConsumeComputeUnits"
            }
            Self::InvalidAccountOwner => "Error: InvalidAccountOwner",
            Self::ArithmeticOverflow => "Error: ArithmeticOverflow",
            Self::Immutable => "Error: Immutable",
            Self::IncorrectAuthority => "Error: IncorrectAuthority",
        }
    }
}
